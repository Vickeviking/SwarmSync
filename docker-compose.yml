services:
  # PostgreSQL database service (only needed for Core)
  postgres:
    image: postgres:15-alpine
    container_name: swarmsync-db
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=app_db
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis in-memory datastore (only needed for Core)
  redis:
    image: redis:7-alpine
    container_name: swarmsync-redis
    # Redis data is ephemeral for development (no persistent volume)

  # Core service (Rust backend API + engine)
  core:
    build: ./core
    container_name: swarmsync-core
    environment:
      - DATABASE_URL=postgres://postgres:postgres@postgres:5432/app_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres # Ensure DB and cache start before core
      - redis
    ports:
      - "8000:8000" # expose core API port
    volumes:
      - ./core:/app # mount source code for live development
    # No profile: core runs by default on `docker compose up`
    entrypoint: ["tail", "-f", "/dev/null"] # keep container running for exec

  # Consumer CLI service (Rust CLI for end-users)
  consumer:
    build:
      context: ./consumer
      dockerfile: Dockerfile
      target: builder # use builder stage so Rust toolchain is present
    container_name: swarmsync-consumer
    working_dir: /usr/src/consumer
    volumes:
      - ./consumer:/usr/src/consumer # mount source for dev
    entrypoint: ["tail", "-f", "/dev/null"] # keep container alive (idle)
    profiles: ["cli"] # only start when profile 'cli' is enabled or explicitly requested
    environment:
      - CORE_API_URL=http://core:8000

  # (Optional) Consumer test runner service
  consumer-test:
    build:
      context: ./consumer
      dockerfile: Dockerfile
      target: builder
    container_name: swarmsync-consumer-test
    working_dir: /usr/src/consumer
    volumes:
      - ./consumer:/usr/src/consumer
    entrypoint: ["cargo"]
    command: ["test"] # runs tests, then exits
    profiles: ["cli"] # also under 'cli' profile (run on demand)

  # Backup service for periodic DB snapshots
  db_backup:
    image: alpine:3.17
    container_name: swarmsync-db-backup
    depends_on:
      - postgres # ensure DB is up before backup service starts
    environment:
      - PGPASSWORD=postgres # allow pg_dump to auth without prompt
    volumes:
      - ./backups:/backups # mount host directory for storing snapshots
    # Cron job: every 10 minutes dump the database to a timestamped file
    command: >
      sh -c "apk add --no-cache postgresql-client &&
             echo '*/10 * * * * pg_dump -h postgres -U postgres app_db > /backups/backup_$(date +\%Y\%m\%d_\%H\%M\%S).sql' > /etc/crontabs/root &&
             crond -f"
    # The above installs the Postgres client and writes a cron entry that runs pg_dump.
    # Snapshots (SQL dumps) will accumulate in the ./backups folder for review or restoration.

volumes:
  postgres_data: {} # Named volume for Postgres data (local, unique per project clone)
